// 동전 2
// 동전 1 문제와 흐름이 비슷하다.
// 점화식 DP[j]

// 2차원 DP
//   0 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15
// 1 - 1 2 3 4 5 6 7 8 9 10 11 12 13 14 15 
// 5 - 1 2 3 4 1 2 3 4 5 2  3  4  5  6  3
// 12- 1 2 3 4 1 2 3 4 5 2  3  1  2  3  3

// 점화식
// DP[j] = min(DP[j], j/coin + DP[j%coin] )

// 안풀림 => 점화식 수정 필요
// 내가 생각한 점화식 유도는 j(달성해야할 목표)를 현재 coin으로 나눈 몫과 나머지.
// 몫 + DP[나머지]가 현재 새로 계산된 애고, 기존의 DP[j]보다 작으면 교체/
// 얘를들어 15에 4라면 15/4 = 3(C++은 정수끼리 계산하면 정수로 준다), 15%4=3
// 3 + DP[3]이다.
// 이 점화식은 현재 coin을 쓸 수 있는 만큼 쓴다는 전제가 깔려있다!!
// 현재 coin을 쓸 수 있는 만큼 쓰는게 꼭 최선이라는 보장이 없다.

// 바뀐 점화식
// dp[j] = min(dp[j], dp[j - coinList[i]] + 1);
// dp[j - coinList[i]] + 1 은 현재 coin을 하나만 쓴다는 의미가 아니다.
// +1로 일단 하나를 쓰고, 지금까지 계산한 경우를 보고 더 쓸 수도 아닐 수도 있다.
// 마찬가지로 15와 4라면, 일단 4를 하나써서 11로 만든다.
// 반복문 서순상 이미 j=11, coin=4가 이미 계산되어있다.
// j=11, coin=4에서 coin 4 가 쓰여졌으면 두개 이상, 안쓰여졌으면 하나.
// 즉 모든 경우가 고려되고, 최종적으로 이전의 최소인 DP[j]와 비교한다.
// 비슷한 문제인 2293 동전 1 의 점화식과 맥락을 같이한다.
// 반복문 서순 상 앞이 이미 계산되어 있다고 가정하며, 일단 현재 j(목표)에서
// 현재 coin을 하나 쓰고, 이미 계산된 DP[j-coin]을 합한다.

#include <iostream>
#include <algorithm>
using namespace std;

int main(){
    int N, K;
    cin >> N >> K;
    int coin[N];
    for(int n = 0 ; n < N ; n++){
        cin >> coin[n];
    } 
    sort(coin, coin+N);

    int DP[K+1] = {0, };
    fill(DP+1, DP+K+1, 100001);

    for(int c = 0 ; c < N ; c++){
        for(int j = coin[c] ; j < K+1 ; j++){
            DP[j] = min(DP[j], 1 + DP[j-coin[c]] );   
        }
    }

    if(DP[K]>=100001){
        DP[K] = -1;
    }
    cout << DP[K] << endl;
}